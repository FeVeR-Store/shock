"use strict";(self["webpackChunkshock"]=self["webpackChunkshock"]||[]).push([[14],{6309:function(l,e,n){n.r(e),n.d(e,{default:function(){return ol}});var o=n(6901),a=n(8146),t=n(2504),u=n(678),d=n(4768);const c=(0,o._)("div",{class:"h-1"},"数据类型 · Data Type",-1),s=(0,o._)("p",null," 编程语言中的值被划分为了多种类型，以便于计算机分辨数据所属的类别，进而进行相应的操作。 ",-1),m=(0,o._)("p",null," 每种编程语言都有其数据类型，但各种编程语言的数据结构常有不同之处，根据已定义的变量能否更改数据类型分类，JavaScript属于动态类型语言，也就是说一个变量的数据类型可以随意变化，不会被限定为某一种数据类型。 ",-1),i=(0,o._)("p",null," 在JavaScript中，数据类型有八种，相比其他语言（如C语言），JavaScript的数据类型较为直白。 ",-1),p=(0,o._)("p",{class:"h-3"},"动态类型与弱类型",-1),g=(0,o._)("p",null,"在JavaScript中，可以随意修改变量的数据类型。",-1),_=(0,o._)("p",null," JavaScript还是弱类型语言，也就是说在操作不同类型的数据时，它会进行隐式类型转换，除非一些特殊情况，否则不会抛出错误。 ",-1),b=(0,o._)("p",null,"支持隐式类型转换是非常方便的，可以省去许多的操作。",-1),f=(0,o._)("p",null," 在这两者的加持之下，JavaScript对于数据的操作极其简单，并且“安全”，不会因为操作数据而全局垮掉。 ",-1),r=(0,o._)("p",null,"下面开始讲解八类数据类型",-1),U=(0,o._)("p",{class:"h-3"},"undefined类型",-1),k=(0,o._)("p",null," undefined类型中只包含一个值：undefined，undefined是变量声明但未赋值的初始值。 ",-1),N=(0,o._)("p",null,"也可以将undefined直接赋值给变量",-1),V=(0,o._)("p",null,[(0,o.Uk)(" 但是不建议这么做，若想表示某变量为空，或者删除原来有值的变量，可以使用"),(0,o._)("code",null,"null")],-1),y=(0,o._)("p",{class:"h-3"},"Null类型",-1),h=(0,o._)("p",null,[(0,o.Uk)(" Null类型中包含一个值："),(0,o._)("code",null,"null"),(0,o.Uk)("，"),(0,o._)("code",null,"null"),(0,o.Uk)("特指对象的值未设置，是代表“无”、“空”或“值未知”的特殊值。 ")],-1),w=(0,o._)("p",{class:"h-3"},"Number类型",-1),S=(0,o._)("p",null," Number类型中可以储存整数和浮点数（小数），可以对这些数字进行多种操作（比如加减乘除运算） ",-1),v=(0,o._)("p",null,[(0,o.Uk)(" 除了常规数字，Number类型还有三个特殊的值："),(0,o._)("code",null,"Infinity"),(0,o.Uk)("（正无穷大）"),(0,o._)("code",null,"-Infinity"),(0,o.Uk)("（负无穷大）和NaN（非数字，not a number） ")],-1),W=(0,o._)("p",null,[(0,o._)("code",null,"Infinity"),(0,o.Uk)("代表数学概念中的无穷大 ∞。是一个比任何数字都大的特殊值。")],-1),I=(0,o._)("p",null,[(0,o._)("code",null,"-Infinity"),(0,o.Uk)("代表数学概念中的负无穷大 -∞，可以用无穷大乘一个负数得到。是一个比任何数字都小的特殊值。 ")],-1),Z=(0,o._)("p",null,"NaN是全局作用域的一个变量，有五种不同类型的的操作会返回NaN。",-1),$=(0,o._)("p",null," NaN是粘性的，mdn描述更为形象：NaN具有传染性；除非进行指数为零的幂运算，否则仍得NaN。 ",-1),D=(0,o._)("p",null,"值得注意的是，NaN具有很多特性，比如它是唯一与自身不相等的值。",-1),B=(0,o._)("p",{class:"h-3"},"BigInt类型",-1),j=(0,o._)("p",null,[(0,o.Uk)(" 在JavaScript中，Number类型无法安全地表示大于2"),(0,o._)("sup",null,"53"),(0,o.Uk)("-1（即9007199254740991）或小于-2"),(0,o._)("sup",null,"53"),(0,o.Uk)("-1（-9007199254740991）的整数，超出后的奇数将出现精度问题。 ")],-1),J=(0,o._)("p",null,"那如何精确地表示超出安全范围的数字呢？BigInt应运而生。",-1),C=(0,o._)("div",{class:"no-br"},[(0,o.Uk)(" 可以在一个整数 "),(0,o._)("div",{class:"no-br","data-help":"字面量|字面量（literal）用于表达源代码中一个固定值的表示法（notation），整数、浮点数以及字符串等等都是字面量，也可以理解为我们为变量赋的值。例如let a = 1; 其中a是变量，b是字面量; MDN的描述：字面量是由语法表达式定义的常量；或，通过由一定字词组成的语词表达式定义的常量"}," 字面量 "),(0,o.Uk)(" 后加“n”定义一个BigInt（也可以使用"),(0,o._)("code",null,"BigInt(...)"),(0,o.Uk)("，由于BigInt不常用，在此不多赘述） ")],-1),E=(0,o._)("p",null,"比如：12345678987654321n",-1),q=(0,o._)("p",null,"需要注意的是，使用BigInt进行数学运算时，类型必须都为BigInt。",-1),M=(0,o._)("p",{class:"h-3"},"String类型",-1),T=(0,o._)("p",null,' String类型用于表示字符串，字符串是一串表示文本值的字符序列，比如"hello World!"，"哈哈哈"，\'123\'都是字符串 ',-1),z=(0,o._)("p",null,[(0,o.Uk)(" JavaScript的字符串必须被括在引号里，包括单引号"),(0,o._)("code",null,"' '"),(0,o.Uk)("，双引号"),(0,o._)("code",null,'" "'),(0,o.Uk)("，和反引号"),(0,o._)("code",null,"` `"),(0,o.Uk)("（在你键盘的Tab键上面） ")],-1),O=(0,o._)("p",null," 其中单引号和双引号在功能上没有什么区别，而反引号则有极其方便的功能：字符串模板。 ",-1),L=(0,o._)("p",null,"使用字符串模板可以轻松地实现许多功能，比如多行字符串",-1),K=(0,o._)("p",null,[(0,o.Uk)("字符串插值允许你方便的将变量插入字符串中，将变量使用"),(0,o._)("code",null,"${}"),(0,o.Uk)("包裹即可")],-1),x=(0,o._)("p",null,"字符串插值也允许你插入表达式",-1),A=(0,o._)("p",{class:"h-3"},"Boolean 类型",-1),G=(0,o._)("p",null," Boolean类型（布尔类型）是编程中相当重要的一个数据类型，它包含两个值：true（真）false（假），这两个值被称为布尔值，布尔值在逻辑判断中有着极其重要的作用。 ",-1),R=(0,o._)("p",null,"布尔值还可以由其他数据类型的值转换而来，也非常方便，以后会详细讲解。",-1),Y=(0,o._)("p",{class:"h-3"},"Symbol类型",-1),F=(0,o._)("p",null,[(0,o.Uk)(" Symbol类型用于创建唯一标识符，Symbol 是唯一并且不可变的原始值并且可以用来作为对象属性的键。可以使用"),(0,o._)("code",null,"Symbol()"),(0,o.Uk)("函数创建一个Symbol ")],-1),H=(0,o._)("p",null," 认真学习的小可爱可能想到了NaN，那玩意好像和这个差不多？很好，勤于思考是很棒的，但可惜并不一样。 ",-1),P=(0,o._)("p",{class:"h-3"},"Object类型",-1),Q=(0,o._)("p",null," Object类型与上述类型都不一样，以上七个类型被称为原始类型（也称为简单数据类型，基本数据类型），其值被称为原始值，而Object类型用于储存数据集合和更复杂的实体，其值object（对象）是指被标识符（变量、常量名）引用的一块区域，也就是说，object的值是引用而来的，因此也被称为引用类型。 ",-1),X=(0,o._)("p",null,"引用类型与原始类型最大的区别是值的传递方式不同",-1),ll=(0,o._)("p",null,"因为object十分重要（是的，对象很重要），我们会在以后详细讲解。",-1);var el={__name:"dataType",setup(l){const e=(0,a.qj)([]);return e[0]='let a = 6; //数字\na = "6啊" //字符串\na = false //布尔值',e[1]='let a = 6; //数字\nlet b = "翻了" //字符串\nconsole.log(a + b) //正常运行，不会报错',e[2]="let a; //声明变量a但未赋值\nconsole.log(a)",e[3]='let a = "我被赋值了"\na = undefined\nconsole.log(a)',e[4]='let a = 1,b = 2,c = 3;\nconsole.log("a + b =",a + b) \nconsole.log("a - b =",a - b)\nconsole.log("a * b =",a * b)\nconsole.log("a / b =",a / b)\nconsole.log("c ** b =",c ** b) //这个是幂运算，3的二次方',e[5]="console.log(1 / 0) //非0数字除以0可得无穷大\nconsole.log(Infinity) //也可以直接使用\nconsole.log(Infinity > 99999999999999999999999)",e[6]="console.log(Infinity * -1)\nconsole.log(-Infinity < -9999999999999999999999)",e[7]='let a = "我不是一个数字", b = 1;\nconsole.log(a - b); //进行一个不正确的或者一个未定义的数学操作\nconsole.log(Number(a)); //进行失败的数字转换 （Number(...)用于将一个值转化为数字\nconsole.log(Math.sqrt(-1)) //进行结果不是实数的数学运算 （Math.sqrt(...)表示开方）\nconsole.log(Infinity-Infinity) //不定式运算\n//无效值被表示为数字\nlet c = new Date(\'2022-02-22 22:22:22\')\nlet d = new Date("哈哈") //Data实例用于呈现时间中的某个时刻。\nconsole.log("这是有效值：",c)\nconsole.log("这是无效值：",d)\nconsole.log("有效值转化为数字：",c.getTime())\nconsole.log("无效值转化为数字：",d.getTime())',e[8]="console.log(NaN + 1);\nconsole.log(NaN * 0);\nconsole.log(NaN - NaN);\nconsole.log(NaN ** 0)//唯一的例外",e[9]="console.log(NaN == NaN);\nconsole.log(NaN === NaN);",e[10]="//下面两个数字都超过了安全范围\nlet a = 9007199254740991+1;\nlet b = 9007199254740991+2;\n//可以看出这两个数字不等\nconsole.log(a === b)\n//但是结果并不如此",e[11]="let a = 9007199254740991n;\nlet b = a + 1n;\nlet c = a + 2n;\nconsole.log(b === c);\nconsole.log(a + 1)//使用不同类型的数字进行运算会报错;",e[12]="let a = \"abc\",\n    b = 'abc',\n    c = `abc`;\nconsole.log(a, b, c)\nconsole.log(a === b, b === c, a === c);//创建字符串与使用的引号无关\nconsole.log(a === b === c) //不能这么检测三个值是不是相同，原因在运算符章节会讲",e[13]="//字符串换行可以使用换行符\nlet b = '我在第一行૮(˶ᵔ ᵕ ᵔ˶)ა\\n我在第二行•ࡇ•?\\n我在最后一行˙Ⱉ˙?' //但比较抽象\nconsole.log(b)\n//反斜杠'\\'是转义符，这个后面会详细讲\n//使用字符串模板\nlet a = `我在第一行૮(˶ᵔ ᵕ ᵔ˶)ა\n我在第二行•ࡇ•\n我在最后一行(˚ ˃̣̣̥᷄⌓˂̣̣̥᷅ )`\nconsole.log(a) //清晰明了",e[14]='//在字符串中插入变量可以采用加号\nlet a = "变量";\nconsole.log("我是" + a + "。")\n//如果需要插入的变量多了，就会很麻烦\nconsole.log(a + "，你要开心，你要幸福，好不好？开心啊，幸福！你的世界以后没有我了，没关系你要自己幸福，" + a + "！" + a + "！" + a + "没有你我怎么活啊！" + a + "！" + a + "！" + a + "！" + a + "！" + a + "！" + a + "！" + a + "你带我走吧" + a + "啊！" + a)//请忽略内容\n//使用字符串模板\nconsole.log(`${a}，你要开心，你要幸福，好不好？开心啊，幸福！你的世界以后没有我了，没关系你要自己幸福，${a}！${a}！${a}没有你我怎么活啊！${a}！${a}！${a}！${a}！${a}！${a}！${a}你带我走吧${a}啊！${a}`)\n//虽然也很长，但是直观了不少，而且少打了很多加号',e[15]='//在字符串中插入表达式需要注意计算顺序\nconsole.log("1+1=" + (1 + 1))\nconsole.log("1+1=" + 1 + 1) //否则就会出现这种智慧答案（具体内容以后会讲）\n//使用字符串模板\nconsole.log(`1+1=${1 + 1}`) //清晰明了\n//在字符串模板中还可以插入更复杂的表达式，这个以后再讲\n',e[16]="//布尔值可以直接使用，这时一般为了表示某个过程的结果（下面的例子只是单纯地赋值）\nlet a = true,b = false;\nconsole.log(a, b);\n//判断结果也通常使用布尔值\nlet c = 2 > 1;\nlet d = 999 < 0;\nconsole.log(c, d);",e[17]="let a = Symbol() //创建了一symbol\nlet b = Symbol() //又创建了一个\nconsole.log(a == b, a === b)\n//每个symbol的值都是唯一的",e[18]="//Symbol 值唯一\nconsole.log(Symbol() == Symbol())\n//哎？这两个判断结果都是false，都是Symbol()，难道不能说明Symbol也不等于自身吗？\nlet a = Symbol(),b = a\nconsole.log(a == b) \nconsole.log(a == a)\n//在这里可以看出，其实是自等的，因为Symbol()是生成器，每调用一次都会产生一个新的symbol，所以上面的不等，而是因为symbol值唯一\n//NaN的不自等\nlet c = NaN, d = c;\nconsole.log(c == d)\nconsole.log(c == c)\n//上面两个结果都是false，可以很清楚的说明了NaN不等于自身",e[19]='let a = 123; //Number\nlet b = 123n //BigInt\nlet c = "abc"; //String\nlet d = undefined; //undefined\nlet e = true;\nlet f = false; //Boolean\nlet g = null; //Null\n//Symbol类型不可修改，故没有添加\n[a,b,c,d,e,f,g].forEach(val=>{\n  let h = val;\n  h= h + "修改内容"\n  console.log(val,"——>", h)\n})  //这堆代码的意思是，将上述每个变量（在处理的过程中名为val）赋值为h，然后再h后添加“修改内容”四个字，然后输出原变量的值和h的值\n//结果应该没有让你惊讶，因为将变量的值赋给h后，变量与h就没有关系了，对h进行更改自然不会影响到原来的变量，这种直接将值传递过去的方式叫做值传递',e[20]='let dog = {name:"汪汪"}; //这是一个对象，包含一个属性（键）name，其值为字符串“汪汪”\nlet myDog = dog; //然后将dog对象赋值给myDog\nmyDog.name = "黄豆"; //然后将myDog的name属性值改为“黄豆”\nconsole.log(dog, myDog) //输出dog和myDog\n//如果使用值传递,dog和myDog应该不同，但实际情况是两个所含的属性和值相同，也就是说，对myDog的修改也对dog有效\n//原因是对于对象的值的传递，传递的是对象的内存地址，而不是对象的值，所以上面操作的其实是一个对象，这种传递内存地址的方式叫做引用传递',(0,o.Y3)().then((()=>{window.setEditor(),setTimeout((()=>{window.pageLoading.close()}),500)})),(l,n)=>((0,o.wg)(),(0,o.iD)(o.HY,null,[c,s,m,i,p,g,(0,o.Wm)(t.Z,{modelValue:e[0],"onUpdate:modelValue":n[0]||(n[0]=l=>e[0]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("JavaScript是一种动态类型语言")])),_:1},8,["modelValue"]),_,b,(0,o.Wm)(t.Z,{modelValue:e[1],"onUpdate:modelValue":n[1]||(n[1]=l=>e[1]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("弱类型语言的隐式类型转换有多方便")])),_:1},8,["modelValue"]),f,r,U,k,(0,o.Wm)(t.Z,{modelValue:e[2],"onUpdate:modelValue":n[2]||(n[2]=l=>e[2]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("undefined")])),_:1},8,["modelValue"]),N,(0,o.Wm)(t.Z,{modelValue:e[3],"onUpdate:modelValue":n[3]||(n[3]=l=>e[3]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("将undefined赋值给变量")])),_:1},8,["modelValue"]),V,y,h,w,S,(0,o.Wm)(t.Z,{modelValue:e[4],"onUpdate:modelValue":n[4]||(n[4]=l=>e[4]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("数字的运算")])),_:1},8,["modelValue"]),v,(0,o.Wm)((0,a.SU)(u.Kf),{style:{"margin-bottom":"15px"},header:"Infinity",title:"Infinity"},{default:(0,o.w5)((()=>[W,(0,o.Wm)(t.Z,{modelValue:e[5],"onUpdate:modelValue":n[5]||(n[5]=l=>e[5]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("示例")])),_:1},8,["modelValue"]),I,(0,o.Wm)(t.Z,{modelValue:e[6],"onUpdate:modelValue":n[6]||(n[6]=l=>e[6]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("示例")])),_:1},8,["modelValue"])])),_:1}),(0,o.Wm)((0,a.SU)(u.Kf),{header:"NaN",title:"NaN"},{default:(0,o.w5)((()=>[Z,(0,o.Wm)(t.Z,{modelValue:e[7],"onUpdate:modelValue":n[7]||(n[7]=l=>e[7]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("五种得到NaN的操作")])),_:1},8,["modelValue"]),$,(0,o.Wm)(t.Z,{modelValue:e[8],"onUpdate:modelValue":n[8]||(n[8]=l=>e[8]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("示例")])),_:1},8,["modelValue"]),D,(0,o.Wm)(t.Z,{modelValue:e[9],"onUpdate:modelValue":n[9]||(n[9]=l=>e[9]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("示例")])),_:1},8,["modelValue"]),(0,o._)("p",null,[(0,o.Uk)(" NaN还有很多特性，可以参考："),(0,o.Wm)((0,a.SU)(d.E2),{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN",type:"primary"},{default:(0,o.w5)((()=>[(0,o.Uk)("MDN的NaN条目")])),_:1})])])),_:1}),B,j,(0,o.Wm)(t.Z,{modelValue:e[10],"onUpdate:modelValue":n[10]||(n[10]=l=>e[10]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("超出安全范围后产生的精度问题")])),_:1},8,["modelValue"]),J,C,E,q,(0,o.Wm)(t.Z,{modelValue:e[11],"onUpdate:modelValue":n[11]||(n[11]=l=>e[11]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("BigInt运算")])),_:1},8,["modelValue"]),(0,o._)("p",null,[(0,o.Uk)(" 正如前面所说，BigInt并不常用，若需要进一步的学习，可以参考："),(0,o.Wm)((0,a.SU)(d.E2),{src:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt",type:"primary"},{default:(0,o.w5)((()=>[(0,o.Uk)("MDN的BigInt条目")])),_:1})]),M,T,z,(0,o.Wm)(t.Z,{modelValue:e[12],"onUpdate:modelValue":n[12]||(n[12]=l=>e[12]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("创建字符串")])),_:1},8,["modelValue"]),O,(0,o.Wm)((0,a.SU)(u.Kf),{header:"字符串模板",title:"字符串模板"},{default:(0,o.w5)((()=>[L,(0,o.Wm)(t.Z,{modelValue:e[13],"onUpdate:modelValue":n[13]||(n[13]=l=>e[13]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("多行字符串")])),_:1},8,["modelValue"]),K,(0,o.Wm)(t.Z,{modelValue:e[14],"onUpdate:modelValue":n[14]||(n[14]=l=>e[14]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("字符串插值")])),_:1},8,["modelValue"]),x,(0,o.Wm)(t.Z,{modelValue:e[15],"onUpdate:modelValue":n[15]||(n[15]=l=>e[15]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("插入表达式")])),_:1},8,["modelValue"])])),_:1}),A,G,(0,o.Wm)(t.Z,{modelValue:e[16],"onUpdate:modelValue":n[16]||(n[16]=l=>e[16]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("布尔值")])),_:1},8,["modelValue"]),R,Y,F,(0,o.Wm)(t.Z,{modelValue:e[17],"onUpdate:modelValue":n[17]||(n[17]=l=>e[17]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("Symbol的创建")])),_:1},8,["modelValue"]),H,(0,o.Wm)(t.Z,{modelValue:e[18],"onUpdate:modelValue":n[18]||(n[18]=l=>e[18]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("Symbol的值唯一与NaN的不自等")])),_:1},8,["modelValue"]),P,Q,X,(0,o.Wm)(t.Z,{modelValue:e[19],"onUpdate:modelValue":n[19]||(n[19]=l=>e[19]=l)},{default:(0,o.w5)((()=>[(0,o.Uk)("原始类型使用值传递")])),_:1},8,["modelValue"]),(0,o.Wm)(t.Z,{modelValue:e[20],"onUpdate:modelValue":n[20]||(n[20]=l=>e[20]=l),style:{"margin-top":"15px"}},{default:(0,o.w5)((()=>[(0,o.Uk)("引用类型使用引用传递")])),_:1},8,["modelValue"]),ll],64))}};const nl=el;var ol=nl},4768:function(l,e,n){n.d(e,{E2:function(){return U}});var o=n(6901),a=n(3265),t=n(8146),u=n(5580),d=n(3736),c=n(7466);const s=(0,d.o8)({type:{type:String,values:["primary","success","warning","info","danger","default"],default:"default"},underline:{type:Boolean,default:!0},disabled:{type:Boolean,default:!1},href:{type:String,default:""},icon:{type:c.AA}}),m={click:l=>l instanceof MouseEvent};var i=n(9847),p=n(9481);const g=["href"],_=(0,o.aZ)({name:"ElLink"}),b=(0,o.aZ)({..._,props:s,emits:m,setup(l,{emit:e}){const n=l,d=(0,p.s)("link"),c=(0,o.Fl)((()=>[d.b(),d.m(n.type),d.is("disabled",n.disabled),d.is("underline",n.underline&&!n.disabled)]));function s(l){n.disabled||e("click",l)}return(l,e)=>((0,o.wg)(),(0,o.iD)("a",{class:(0,a.C_)((0,t.SU)(c)),href:l.disabled||!l.href?void 0:l.href,onClick:s},[l.icon?((0,o.wg)(),(0,o.j4)((0,t.SU)(u.gn),{key:0},{default:(0,o.w5)((()=>[((0,o.wg)(),(0,o.j4)((0,o.LL)(l.icon)))])),_:1})):(0,o.kq)("v-if",!0),l.$slots.default?((0,o.wg)(),(0,o.iD)("span",{key:1,class:(0,a.C_)((0,t.SU)(d).e("inner"))},[(0,o.WI)(l.$slots,"default")],2)):(0,o.kq)("v-if",!0),l.$slots.icon?(0,o.WI)(l.$slots,"icon",{key:2}):(0,o.kq)("v-if",!0)],10,g))}});var f=(0,i.Z)(b,[["__file","/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]),r=n(9293);const U=(0,r.nz)(f)}}]);
//# sourceMappingURL=14.a15f4af9.js.map