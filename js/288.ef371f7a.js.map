{"version":3,"file":"js/288.ef371f7a.js","mappings":"8vHAsJA,MAAMA,GAAQC,EAAAA,EAAAA,IAAS,I,OACvBD,EAAM,GAAM,mDAGZA,EAAM,GAAM,sEAGZA,EAAM,GAAM,qCAEZA,EAAM,GAAM,iDAGZA,EAAM,GAAM,iMAMZA,EAAM,GAAM,sHAGZA,EAAM,GAAM,+EAEZA,EAAM,GAAM,kdAYZA,EAAM,GAAM,sGAIZA,EAAM,GAAM,sDAEZA,EAAM,IAAO,8HAMbA,EAAM,IAAO,6HAKbA,EAAM,IAAO,yLAMbA,EAAM,IAAO,sNASbA,EAAM,IAAO,ycAQbA,EAAM,IAAO,2LAObA,EAAM,IAAO,+JAObA,EAAM,IAAO,4GAIbA,EAAM,IAAO,iWAYbA,EAAM,IAAO,yaAcbA,EAAM,IAAO,2TAMbE,EAAAA,EAAAA,MAAWC,MAAK,KACdC,OAAOC,YACPC,YAAW,KACTF,OAAOG,YAAYC,OAAO,GACzB,IAAI,I,ogICpRT,MAAMC,GAAc,GAEpB,S,wHCJY,MAACC,GAAYC,EAAAA,EAAAA,IAAW,CAClCC,KAAM,CACJA,KAAMC,OACNC,OAAQ,CAAC,UAAW,UAAW,UAAW,OAAQ,SAAU,WAC5DC,QAAS,WAEXC,UAAW,CACTJ,KAAMK,QACNF,SAAS,GAEXG,SAAU,CAAEN,KAAMK,QAASF,SAAS,GACpCI,KAAM,CAAEP,KAAMC,OAAQE,QAAS,IAC/BK,KAAM,CACJR,KAAMS,EAAAA,MAGGC,EAAY,CACvBC,MAAQC,GAAQA,aAAeC,Y,oDCGnB,CACZC,KAAM,W,6DAKFC,GAAKC,EAAAA,EAAAA,GAAa,QAElBC,GAAUC,EAAAA,EAAAA,KAAS,IAAM,CAC7BH,EAAGI,IACHJ,EAAGK,EAAEC,EAAMrB,MACXe,EAAGO,GAAG,WAAYD,EAAMf,UACxBS,EAAGO,GAAG,YAAaD,EAAMjB,YAAciB,EAAMf,aAG/C,SAASiB,EAAYC,GACdH,EAAMf,UAAUmB,EAAK,QAASD,EAAK,C,qmBCnC9B,MAACE,GAASC,EAAAA,EAAAA,IAAYC,E","sources":["webpack://shock/./src/components/dataType.vue","webpack://shock/./src/components/dataType.vue?8398","webpack://shock/../../packages/components/link/src/link.ts","webpack://shock/../../packages/components/link/src/link.vue","webpack://shock/../../packages/components/link/index.ts"],"sourcesContent":["<template>\r\n  <div class=\"h-1\">数据类型 · Data Type</div>\r\n  <p>\r\n    编程语言中的值被划分为了多种类型，以便于计算机分辨数据所属的类别，进而进行相应的操作。\r\n  </p>\r\n  <p>\r\n    每种编程语言都有其数据类型，但各种编程语言的数据结构常有不同之处，根据已定义的变量能否更改数据类型分类，JavaScript属于动态类型语言，也就是说一个变量的数据类型可以随意变化，不会被限定为某一种数据类型。\r\n  </p>\r\n  <p>\r\n    在JavaScript中，数据类型有八种，相比其他语言（如C语言），JavaScript的数据类型较为直白。\r\n  </p>\r\n  <p class=\"h-3\">动态类型与弱类型</p>\r\n  <p>在JavaScript中，可以随意修改变量的数据类型。</p>\r\n  <code-editor v-model=\"codes[0]\">JavaScript是一种动态类型语言</code-editor>\r\n  <p>\r\n    JavaScript还是弱类型语言，也就是说在操作不同类型的数据时，它会进行隐式类型转换，除非一些特殊情况，否则不会抛出错误。\r\n  </p>\r\n  <p>支持隐式类型转换是非常方便的，可以省去许多的操作。</p>\r\n  <code-editor v-model=\"codes[1]\">弱类型语言的隐式类型转换有多方便</code-editor>\r\n  <p>\r\n    在这两者的加持之下，JavaScript对于数据的操作极其简单，并且“安全”，不会因为操作数据而全局垮掉。\r\n  </p>\r\n  <p>下面开始讲解八类数据类型</p>\r\n  <p class=\"h-3\">undefined类型</p>\r\n  <p>\r\n    undefined类型中只包含一个值：undefined，undefined是变量声明但未赋值的初始值。\r\n  </p>\r\n  <code-editor v-model=\"codes[2]\">undefined</code-editor>\r\n  <p>也可以将undefined直接赋值给变量</p>\r\n  <code-editor v-model=\"codes[3]\">将undefined赋值给变量</code-editor>\r\n  <p>\r\n    但是不建议这么做，若想表示某变量为空，或者删除原来有值的变量，可以使用null\r\n  </p>\r\n  <p class=\"h-3\">Null类型</p>\r\n  <p>\r\n    Null类型中包含一个值：null，值 null\r\n    特指对象的值未设置，是代表“无”、“空”或“值未知”的特殊值。\r\n  </p>\r\n  <p class=\"h-3\">Number类型</p>\r\n  <p>\r\n    Number类型中可以储存整数和浮点数（小数），可以对这些数字进行多种操作（比如加减乘除运算）\r\n  </p>\r\n  <code-editor v-model=\"codes[4]\">数字的运算</code-editor>\r\n  <p>\r\n    除了常规数字，Number类型还有三个特殊的值：Infinity（正无穷大）-Infinity（负无穷大）和NaN（非数字，not\r\n    a number）\r\n  </p>\r\n  <el-card style=\"margin-bottom: 15px\" header=\"Infinity\" title=\"Infinity\">\r\n    <p>Infinity代表数学概念中的无穷大 ∞。是一个比任何数字都大的特殊值。</p>\r\n    <code-editor v-model=\"codes[5]\">示例</code-editor>\r\n    <p>\r\n      -Infinity代表数学概念中的负无穷大\r\n      -∞，可以用无穷大乘一个负数得到。是一个比任何数字都小的特殊值。\r\n    </p>\r\n    <code-editor v-model=\"codes[6]\">示例</code-editor>\r\n  </el-card>\r\n  <el-card header=\"NaN\" title=\"NaN\">\r\n    <p>NaN是全局作用域的一个变量，有五种不同类型的的操作会返回NaN。</p>\r\n    <code-editor v-model=\"codes[7]\">五种得到NaN的操作</code-editor>\r\n    <p>\r\n      NaN是粘性的，mdn描述更为形象：NaN具有传染性；除非进行指数为零的幂运算，否则仍得NaN。\r\n    </p>\r\n    <code-editor v-model=\"codes[8]\">示例</code-editor>\r\n    <p>值得注意的是，NaN具有很多特性，比如它是唯一与自身不相等的值。</p>\r\n    <code-editor v-model=\"codes[9]\">示例</code-editor>\r\n    <p>\r\n      NaN还有很多特性，可以参考：<el-link\r\n        href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN\"\r\n        type=\"primary\"\r\n        >MDN的NaN条目</el-link\r\n      >\r\n    </p>\r\n  </el-card>\r\n  <p class=\"h-3\">BigInt类型</p>\r\n  <p>\r\n    在JavaScript中，Number类型无法安全地表示大于2<sup>53</sup>-1（即9007199254740991）或小于-2<sup>53</sup>-1（-9007199254740991）的整数，超出后的奇数将出现精度问题。\r\n  </p>\r\n  <code-editor v-model=\"codes[10]\">超出安全范围后产生的精度问题</code-editor>\r\n  <p>那如何精确地表示超出安全范围的数字呢？BigInt应运而生。</p>\r\n  <div class=\"no-br\">\r\n    可以在一个整数\r\n    <div\r\n      class=\"no-br\"\r\n      data-help=\"字面量|字面量（literal）用于表达源代码中一个固定值的表示法（notation），整数、浮点数以及字符串等等都是字面量，也可以理解为我们为变量赋的值。例如let a = 1; 其中a是变量，b是字面量; MDN的描述：字面量是由语法表达式定义的常量；或，通过由一定字词组成的语词表达式定义的常量\"\r\n    >\r\n      字面量\r\n    </div>\r\n    后加“n”定义一个BigInt（也可以使用BigInt(...)，由于BigInt不常用，在此不多赘述）\r\n  </div>\r\n  <p>比如：12345678987654321n</p>\r\n  <p>需要注意的是，使用BigInt进行数学运算时，类型必须都为BigInt。</p>\r\n  <code-editor v-model=\"codes[11]\">BigInt运算</code-editor>\r\n  <p>\r\n    正如前面所说，BigInt并不常用，若需要进一步的学习，可以参考：<el-link\r\n      src=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt\"\r\n      type=\"primary\"\r\n      >MDN的BigInt条目</el-link\r\n    >\r\n  </p>\r\n  <p class=\"h-3\">String类型</p>\r\n  <p>\r\n    String类型用于表示字符串，字符串是一串表示文本值的字符序列，比如\"hello\r\n    World!\"，\"哈哈哈\"，'123'都是字符串\r\n  </p>\r\n  <p>\r\n    JavaScript的字符串必须被括在引号里，包括单引号（' '），双引号（\"\r\n    \"），和反引号（` `，在你键盘的Tab键上面）\r\n  </p>\r\n  <code-editor v-model=\"codes[12]\">创建字符串</code-editor>\r\n  <p>\r\n    其中单引号和双引号在功能上没有什么区别，而反引号则有极其方便的功能：字符串模板。\r\n  </p>\r\n  <el-card header=\"字符串模板\" title=\"字符串模板\">\r\n    <p>使用字符串模板可以轻松地实现许多功能，比如多行字符串</p>\r\n    <code-editor v-model=\"codes[13]\">多行字符串</code-editor>\r\n    <p>字符串插值允许你方便的将变量插入字符串中，将变量使用${}包裹即可</p>\r\n    <code-editor v-model=\"codes[14]\">字符串插值</code-editor>\r\n    <p>字符串插值也允许你插入表达式</p>\r\n    <code-editor v-model=\"codes[15]\">插入表达式</code-editor>\r\n  </el-card>\r\n  <p class=\"h-3\">Boolean 类型</p>\r\n  <p>\r\n    Boolean类型（布尔类型）是编程中相当重要的一个数据类型，它包含两个值：true（真）false（假），这两个值被称为布尔值，布尔值在逻辑判断中有着极其重要的作用。\r\n  </p>\r\n  <code-editor v-model=\"codes[16]\">布尔值</code-editor>\r\n  <p>布尔值还可以由其他数据类型的值转换而来，也非常方便，以后会详细讲解。</p>\r\n  <p class=\"h-3\">Symbol类型</p>\r\n  <p>\r\n    Symbol类型用于创建唯一标识符，Symbol\r\n    是唯一并且不可变的原始值并且可以用来作为对象属性的键。可以使用Symbol()函数创建一个Symbol\r\n  </p>\r\n  <code-editor v-model=\"codes[17]\">Symbol的创建</code-editor>\r\n  <p>\r\n    认真学习的小可爱可能想到了NaN，那玩意好像和这个差不多？很好，勤于思考是很棒的，但可惜并不一样。\r\n  </p>\r\n  <code-editor v-model=\"codes[18]\">Symbol的值唯一与NaN的不自等</code-editor>\r\n  <p class=\"h-3\">Object类型</p>\r\n  <p>\r\n    Object类型与上述类型都不一样，以上七个类型被称为原始类型（也称为简单数据类型，基本数据类型），其值被称为原始值，而Object类型用于储存数据集合和更复杂的实体，其值object（对象）是指被标识符（变量、常量名）引用的一块区域，也就是说，object的值是引用而来的，因此也被称为引用类型。\r\n  </p>\r\n  <p>引用类型与原始类型最大的区别是值的传递方式不同</p>\r\n  <code-editor v-model=\"codes[19]\">原始类型使用值传递</code-editor>\r\n  <code-editor v-model=\"codes[20]\" style=\"margin-top:15px\" >引用类型使用引用传递</code-editor>\r\n  <p>因为object十分重要（是的，对象很重要），我们会在以后详细讲解。</p>\r\n</template>\r\n\r\n<script setup>\r\nimport { nextTick, reactive } from \"vue\";\r\nimport codeEditor from \"./codeEditor.vue\";\r\nimport { ElCard, ElLink } from \"element-plus\";\r\nconst codes = reactive([]);\r\ncodes[0] = `let a = 6; //数字\r\na = \"6啊\" //字符串\r\na = false //布尔值`;\r\ncodes[1] = `let a = 6; //数字\r\nlet b = \"翻了\" //字符串\r\nconsole.log(a + b) //正常运行，不会报错`;\r\ncodes[2] = `let a; //声明变量a但未赋值\r\nconsole.log(a)`;\r\ncodes[3] = `let a = \"我被赋值了\"\r\na = undefined\r\nconsole.log(a)`;\r\ncodes[4] = `let a = 1,b = 2,c = 3;\r\nconsole.log(\"a + b =\",a + b) \r\nconsole.log(\"a - b =\",a - b)\r\nconsole.log(\"a * b =\",a * b)\r\nconsole.log(\"a / b =\",a / b)\r\nconsole.log(\"c ** b =\",c ** b) //这个是幂运算，3的二次方`;\r\ncodes[5] = `console.log(1 / 0) //非0数字除以0可得无穷大\r\nconsole.log(Infinity) //也可以直接使用\r\nconsole.log(Infinity > 99999999999999999999999)`;\r\ncodes[6] = `console.log(Infinity * -1)\r\nconsole.log(-Infinity < -9999999999999999999999)`;\r\ncodes[7] = `let a = \"我不是一个数字\", b = 1;\r\nconsole.log(a - b); //进行一个不正确的或者一个未定义的数学操作\r\nconsole.log(Number(a)); //进行失败的数字转换 （Number(...)用于将一个值转化为数字\r\nconsole.log(Math.sqrt(-1)) //进行结果不是实数的数学运算 （Math.sqrt(...)表示开方）\r\nconsole.log(Infinity-Infinity) //不定式运算\r\n//无效值被表示为数字\r\nlet c = new Date('2022-02-22 22:22:22')\r\nlet d = new Date(\"哈哈\") //Data实例用于呈现时间中的某个时刻。\r\nconsole.log(\"这是有效值：\",c)\r\nconsole.log(\"这是无效值：\",d)\r\nconsole.log(\"有效值转化为数字：\",c.getTime())\r\nconsole.log(\"无效值转化为数字：\",d.getTime())`;\r\ncodes[8] = `console.log(NaN + 1);\r\nconsole.log(NaN * 0);\r\nconsole.log(NaN - NaN);\r\nconsole.log(NaN ** 0)//唯一的例外`;\r\ncodes[9] = `console.log(NaN == NaN);\r\nconsole.log(NaN === NaN);`;\r\ncodes[10] = `//下面两个数字都超过了安全范围\r\nlet a = 9007199254740991+1;\r\nlet b = 9007199254740991+2;\r\n//可以看出这两个数字不等\r\nconsole.log(a === b)\r\n//但是结果并不如此`;\r\ncodes[11] = `let a = 9007199254740991n;\r\nlet b = a + 1n;\r\nlet c = a + 2n;\r\nconsole.log(b === c);\r\nconsole.log(a + 1)//使用不同类型的数字进行运算会报错;`;\r\ncodes[12] = `let a = \"abc\",\r\n    b = 'abc',\r\n    c = \\`abc\\`;\r\nconsole.log(a, b, c)\r\nconsole.log(a === b, b === c, a === c);//创建字符串与使用的引号无关\r\nconsole.log(a === b === c) //不能这么检测三个值是不是相同，原因在运算符章节会讲`;\r\ncodes[13] = `//字符串换行可以使用换行符\r\nlet b = '我在第一行૮(˶ᵔ ᵕ ᵔ˶)ა\\\\n我在第二行•ࡇ•?\\\\n我在最后一行˙Ⱉ˙?' //但比较抽象\r\nconsole.log(b)\r\n//反斜杠'\\\\'是转义符，这个后面会详细讲\r\n//使用字符串模板\r\nlet a = \\`我在第一行૮(˶ᵔ ᵕ ᵔ˶)ა\r\n我在第二行•ࡇ•\r\n我在最后一行(˚ ˃̣̣̥᷄⌓˂̣̣̥᷅ )\\`\r\nconsole.log(a) //清晰明了`;\r\ncodes[14] = `//在字符串中插入变量可以采用加号\r\nlet a = \"变量\";\r\nconsole.log(\"我是\" + a + \"。\")\r\n//如果需要插入的变量多了，就会很麻烦\r\nconsole.log(a + \"，你要开心，你要幸福，好不好？开心啊，幸福！你的世界以后没有我了，没关系你要自己幸福，\" + a + \"！\" + a + \"！\" + a + \"没有你我怎么活啊！\" + a + \"！\" + a + \"！\" + a + \"！\" + a + \"！\" + a + \"！\" + a + \"！\" + a + \"你带我走吧\" + a + \"啊！\" + a)//请忽略内容\r\n//使用字符串模板\r\nconsole.log(\\`\\${a}，你要开心，你要幸福，好不好？开心啊，幸福！你的世界以后没有我了，没关系你要自己幸福，\\${a}！\\${a}！\\${a}没有你我怎么活啊！\\${a}！\\${a}！\\${a}！\\${a}！\\${a}！\\${a}！\\${a}你带我走吧\\${a}啊！\\${a}\\`)\r\n//虽然也很长，但是直观了不少，而且少打了很多加号`;\r\ncodes[15] = `//在字符串中插入表达式需要注意计算顺序\r\nconsole.log(\"1+1=\" + (1 + 1))\r\nconsole.log(\"1+1=\" + 1 + 1) //否则就会出现这种智慧答案（具体内容以后会讲）\r\n//使用字符串模板\r\nconsole.log(\\`1+1=\\${1 + 1}\\`) //清晰明了\r\n//在字符串模板中还可以插入更复杂的表达式，这个以后再讲\r\n`;\r\ncodes[16] = `//布尔值可以直接使用，这时一般为了表示某个过程的结果（下面的例子只是单纯地赋值）\r\nlet a = true,b = false;\r\nconsole.log(a, b);\r\n//判断结果也通常使用布尔值\r\nlet c = 2 > 1;\r\nlet d = 999 < 0;\r\nconsole.log(c, d);`;\r\ncodes[17] = `let a = Symbol() //创建了一symbol\r\nlet b = Symbol() //又创建了一个\r\nconsole.log(a == b, a === b)\r\n//每个symbol的值都是唯一的`;\r\ncodes[18] = `//Symbol 值唯一\r\nconsole.log(Symbol() == Symbol())\r\n//哎？这两个判断结果都是false，都是Symbol()，难道不能说明Symbol也不等于自身吗？\r\nlet a = Symbol(),b = a\r\nconsole.log(a == b) \r\nconsole.log(a == a)\r\n//在这里可以看出，其实是自等的，因为Symbol()是生成器，每调用一次都会产生一个新的symbol，所以上面的不等，而是因为symbol值唯一\r\n//NaN的不自等\r\nlet c = NaN, d = c;\r\nconsole.log(c == d)\r\nconsole.log(c == c)\r\n//上面两个结果都是false，可以很清楚的说明了NaN不等于自身`;\r\ncodes[19] = `let a = 123; //Number\r\nlet b = 123n //BigInt\r\nlet c = \"abc\"; //String\r\nlet d = undefined; //undefined\r\nlet e = true;\r\nlet f = false; //Boolean\r\nlet g = null; //Null\r\n//Symbol类型不可修改，故没有添加\r\n[a,b,c,d,e,f,g].forEach(val=>{\r\n  let h = val;\r\n  h= h + \"修改内容\"\r\n  console.log(val, h)\r\n})  //这堆代码的意思是，将上述每个变量（在处理的过程中名为val）赋值为h，然后再h后添加“修改内容”四个字，然后输出原变量的值和h的值\r\n//结果应该没有让你惊讶，因为将变量的值赋给h后，变量与h就没有关系了，对h进行更改自然不会影响到原来的变量，这种直接将值传递过去的方式叫做值传递`;\r\ncodes[20] = `let dog = {name:\"汪汪\"}; //这是一个对象，包含一个属性（键）name，其值为字符串“汪汪”\r\nlet myDog = dog; //然后将dog对象赋值给myDog\r\nmyDog.name = \"黄豆\"; //然后将myDog的name属性值改为“黄豆”\r\nconsole.log(dog, myDog) //输出dog和myDog\r\n//如果使用值传递,dog和myDog应该不同，但实际情况是两个所含的属性和值相同，也就是说，对myDog的修改也对dog有效\r\n//原因是对于对象的值的传递，传递的是对象的内存地址，而不是对象的值，所以上面操作的其实是一个对象，这种传递内存地址的方式叫做引用传递`;\r\nnextTick().then(() => {\r\n  window.setEditor();\r\n  setTimeout(() => {\r\n    window.pageLoading.close();\r\n  }, 500);\r\n});\r\n</script>\r\n\r\n<style lang=\"scss\" scoped></style>\r\n","import script from \"./dataType.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./dataType.vue?vue&type=script&setup=true&lang=js\"\n\nconst __exports__ = script;\n\nexport default __exports__","import { buildProps, iconPropType } from '@element-plus/utils'\nimport type { ExtractPropTypes } from 'vue'\nimport type Link from './link.vue'\n\nexport const linkProps = buildProps({\n  /**\n   * @description type\n   */\n  type: {\n    type: String,\n    values: ['primary', 'success', 'warning', 'info', 'danger', 'default'],\n    default: 'default',\n  },\n  /**\n   * @description whether the component has underline\n   */\n  underline: {\n    type: Boolean,\n    default: true,\n  },\n  /**\n   * @description whether the component is disabled\n   */\n  disabled: { type: Boolean, default: false },\n  /**\n   * @description same as native hyperlink's `href`\n   */\n  href: { type: String, default: '' },\n  /**\n   * @description icon component\n   */\n  icon: {\n    type: iconPropType,\n  },\n} as const)\nexport type LinkProps = ExtractPropTypes<typeof linkProps>\n\nexport const linkEmits = {\n  click: (evt: MouseEvent) => evt instanceof MouseEvent,\n}\nexport type LinkEmits = typeof linkEmits\n\nexport type LinkInstance = InstanceType<typeof Link>\n","<template>\n  <a\n    :class=\"linkKls\"\n    :href=\"disabled || !href ? undefined : href\"\n    @click=\"handleClick\"\n  >\n    <el-icon v-if=\"icon\"><component :is=\"icon\" /></el-icon>\n    <span v-if=\"$slots.default\" :class=\"ns.e('inner')\">\n      <slot />\n    </span>\n\n    <slot v-if=\"$slots.icon\" name=\"icon\" />\n  </a>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed } from 'vue'\nimport { ElIcon } from '@element-plus/components/icon'\nimport { useNamespace } from '@element-plus/hooks'\nimport { linkEmits, linkProps } from './link'\n\ndefineOptions({\n  name: 'ElLink',\n})\nconst props = defineProps(linkProps)\nconst emit = defineEmits(linkEmits)\n\nconst ns = useNamespace('link')\n\nconst linkKls = computed(() => [\n  ns.b(),\n  ns.m(props.type),\n  ns.is('disabled', props.disabled),\n  ns.is('underline', props.underline && !props.disabled),\n])\n\nfunction handleClick(event: MouseEvent) {\n  if (!props.disabled) emit('click', event)\n}\n</script>\n","import { withInstall } from '@element-plus/utils'\n\nimport Link from './src/link.vue'\n\nexport const ElLink = withInstall(Link)\nexport default ElLink\n\nexport * from './src/link'\n"],"names":["codes","reactive","nextTick","then","window","setEditor","setTimeout","pageLoading","close","__exports__","linkProps","buildProps","type","String","values","default","underline","Boolean","disabled","href","icon","iconPropType","linkEmits","click","evt","MouseEvent","name","ns","useNamespace","linkKls","computed","b","m","props","is","handleClick","event","emit","ElLink","withInstall","Link"],"sourceRoot":""}